{"version":3,"sources":["../../src/checkTypes.ts","../../src/isEmpty.ts","../../src/components/Show/Show.tsx","../../src/components/Each/Each.tsx","../../src/utils/memoize.ts","../../src/utils/memoizeCapped.ts","../../src/utils/stringToPath.ts","../../src/tests/isEmpty.test.ts"],"sourcesContent":["import { DATATYPE } from \"./types/common\"\n\nexport const checkType = <T>(value:T)  =>\n    Object.prototype.toString.call(value).slice(8, -1) as DATATYPE\n\nexport const isObject = <T>(value: T) => checkType(value) === DATATYPE.Object\nexport const isArray  = <T>(value: T) => checkType(value) === DATATYPE.Array\nexport const isNaN    = <T>(value: T) => checkType(value) === DATATYPE.NaN\nexport const isFunction = <T>(value: T) => checkType(value) === DATATYPE.Function\nexport const isNumber = <T>(value: T) => checkType(value) === DATATYPE.Number\nexport const isString = <T>(value: T) => checkType(value) === DATATYPE.String\nexport const isSymbol = <T>(value: T) => checkType(value) === DATATYPE.Symbol\nexport const isNull   = <T>(value: T) => checkType(value) === DATATYPE.Null\nexport const isUndefined   = <T>(value: T) => checkType(value) === DATATYPE.Undefined\n\nconst checkTypeInstance = {\n    isObject,\n    isArray,\n    isNaN,\n    isFunction,\n    checkType,\n    isString,\n    isNumber,\n    isSymbol,\n    isNull,\n    isUndefined\n}\nexport default checkTypeInstance\n\n","import { isArray, isString } from \"./checkTypes\";\n\nconst isEmpty = <T>(val: T) => {\n\n    if(!val) return true;\n\n    // Check for an empty array\n    if(isArray(val) && val instanceof Array) {\n        return !val.length;\n    }\n    // Check for an empty string or array\n\n    if (isString(val) && val instanceof String) return !(val.trim().length === 0)\n\n    // Check for an empty Map or Set\n\n    if(val instanceof Map || val instanceof Set) {\n        return !val.size\n    }\n\n    return !Object.keys(val ?? {}).length\n}\nexport default isEmpty\n","import { Children, isValidElement, PropsWithChildren, ReactElement, ReactNode } from 'react'\nimport {Nullable} from \"../../types/common\";\n\n\ninterface ShowProps {}\n\ninterface ChildProps {\n    isTrue?: boolean\n}\n\nconst Show = ({ children }: PropsWithChildren<ShowProps>) => {\n    let when: Nullable<ReactElement<ChildProps>> = null\n    let otherwise: Nullable<ReactElement<ChildProps>> = null\n\n    Children.forEach(children, (child) => {\n        if (!isValidElement<ChildProps>(child)) return\n\n        if (!child.props.isTrue) {\n            otherwise = child\n        } else if (child.props.isTrue && !when) {\n            when = child\n        }\n    })\n\n    return when || otherwise\n}\n\nShow.When = ({ children, isTrue }: PropsWithChildren<ChildProps>) => {\n    return isTrue && children\n}\nShow.Else = ({\n                 children,\n                 render\n             }: PropsWithChildren<\n    ChildProps & {\n    render?: ReactNode\n}\n>) => {\n    return render || children\n}\n\nexport default Show","import React, { Children, Fragment } from 'react'\nimport Show from \"../Show/Show\";\n\ninterface EachProps<T> {\n    list: T[] | readonly T[];\n    render: (item: T, index: number) => React.ReactNode\n    empty?: React.ReactNode\n}\n\nconst Each = <T,>({ list, render, empty }: EachProps<T>) => {\n    return (\n        <Fragment>\n            {\n                <Show>\n                    <Show.When isTrue={Array.isArray(list) && list.length > 0}>{Children.toArray(list.map(render))}</Show.When>\n                    <Show.Else>{empty}</Show.Else>\n                </Show>\n            }\n        </Fragment>\n    )\n}\n\nexport default Each\n\n\n","import { isFunction } from \"../checkTypes\";\n\n/**\n * Creates a function that memoizes the result of `func`. If `resolver` is\n * provided, it determines the cache key for storing the result based on the\n * arguments provided to the memoized function. By default, the first argument\n * provided to the memoized function is used as the map cache key. The `func`\n * is invoked with the `this` binding of the memoized function.\n *\n * **Note:** The cache is exposed as the `cache` property on the memoized\n * function. Its creation may be customized by replacing the `memoize.Cache`\n * constructor with one whose instances implement the\n * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n * method interface of `clear`, `delete`, `get`, `has`, and `set`.\n *\n*/\nexport type TKey =  [key?: TKey, ...rest: any[]]\nexport type TFunction = (...args:  TKey) => string[]\nexport type MemFunction = TFunction & {\n    cache? :Map<any,any>\n};\n\nconst memoize = (func:TFunction, resolver :TFunction) => {\n    if (!isFunction(func) || !isFunction(resolver)) {\n        throw new TypeError('Expected a function');\n    }\n    const memoized = (...args: TKey) => {\n        const key = resolver ? resolver.apply(null, args) : args[0];\n        const cache = memoized.cache as Map<any,any>;\n\n        if (cache.has(key)) {\n            return cache.get(key);\n        }\n        const result = func.apply(null, args);\n        memoized.cache = cache.set(key, result) || cache;\n        return result;\n    };\n    memoized.cache = new (memoize.Cache || Map)();\n    return memoized;\n}\n\nmemoize.Cache = Map;\n\nexport default memoize;","import memoize, {MemFunction, TFunction, TKey} from \"./memoize\";\n\n/** Used as the maximum memoize cache size. */\nconst MAX_MEMOIZE_SIZE = 500\n\n/**\n * A specialized version of `memoize` which clears the memoized function's\n * cache when it exceeds `MAX_MEMOIZE_SIZE`.\n */\nconst memoizeCapped = <T extends MemFunction>(func: TFunction) : T => {\n    const result = memoize(func, (...key : TKey) : string[] => {\n        const { cache } = result\n        if (cache?.size === MAX_MEMOIZE_SIZE) {\n            cache?.clear()\n        }\n        return key\n    }) as T\n\n    return result\n}\n\nexport default memoizeCapped","import memoizeCapped from './memoizeCapped'\nimport { isString } from \"../checkTypes\";\n\nconst charCodeOfDot = '.'.charCodeAt(0)\nconst reEscapeChar = /\\\\(\\\\)?/g\nconst rePropName = RegExp(\n    // Match anything that isn't a dot or bracket.\n    '[^.[\\\\]]+' + '|' +\n    // Or match property names within brackets.\n    '\\\\[(?:' +\n    // Match a non-string expression.\n    '([^\"\\'][^[]*)' + '|' +\n    // Or match strings (supports escaping characters).\n    '([\"\\'])((?:(?!\\\\2)[^\\\\\\\\]|\\\\\\\\.)*?)\\\\2' +\n    ')\\\\]'+ '|' +\n    // Or match \"\" as the space between consecutive dots or empty brackets.\n    '(?=(?:\\\\.|\\\\[\\\\])(?:\\\\.|\\\\[\\\\]|$))'\n    , 'g')\n\nconst stringToPath = memoizeCapped((str?: string | string[]) : string[]  => {\n    const result : string[] = []\n    if(!isString(str)) return result\n    if ((str as string)?.charCodeAt(0) === charCodeOfDot) {\n        result.push('')\n    }\n    (str as string)?.replace(rePropName, (match: string, expression?: string, quote?: string, subString?: string) : any   => {\n        let key = match\n        if (quote) {\n            key = subString?.replace(reEscapeChar, '$1') ?? ''\n        }\n        else if (expression) {\n            key = expression.trim()\n        }\n        result.push(key)\n    })\n    return result\n})\n\nexport default stringToPath","// Assuming isEmpty is defined in a file named isEmpty.ts\nimport { isEmpty } from \"../index\";\n\ndescribe('isEmpty function', () => {\n    it('should return true for an empty string', () => {\n        expect(isEmpty('')).toBe(true);\n    });\n\n    it('should return true for an empty array', () => {\n        expect(isEmpty([])).toBe(true);\n    });\n\n    it('should return true for an empty object', () => {\n        expect(isEmpty({})).toBe(true);\n    });\n\n    it('should return false for a non-empty string', () => {\n        expect(isEmpty('hello')).toBe(false);\n    });\n\n    it('should return false for a non-empty array', () => {\n        expect(isEmpty([1, 2, 3])).toBe(false);\n    });\n\n    it('should return false for a non-empty object', () => {\n        expect(isEmpty({ name: 'John', age: 30 })).toBe(false);\n    });\n\n    it('should handle null and undefined values', () => {\n        expect(isEmpty(null)).toBe(true);\n        expect(isEmpty(undefined)).toBe(true);\n    });\n});"],"mappings":"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","names":["checkType","value","isArray","value","checkType","isFunction","value","checkType","isString","value","checkType","isEmpty","val","isArray","isString","isEmpty_default","import_react","Show","children","when","otherwise","child","isTrue","render","import_react","memoize","func","resolver","isFunction","memoized","args","key","cache","result","memoize_default","MAX_MEMOIZE_SIZE","memoizeCapped","func","result","memoize_default","key","cache","memoizeCapped_default","charCodeOfDot","reEscapeChar","rePropName","stringToPath","memoizeCapped_default","str","result","isString","match","expression","quote","subString","_a","key","isEmpty_default"]}