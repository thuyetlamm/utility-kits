{"version":3,"sources":["../../src/get.ts","../../src/components/Show/Show.tsx","../../src/components/Each/Each.tsx","../../src/tests/get.test.ts"],"sourcesContent":["import {NestedKeyOf, NestedKeyValue} from \"./types/get\";\n\n\nconst get = <T extends object, K extends NestedKeyOf<T>>(\n    obj: T,\n    key: K,\n    defaultValue?: NestedKeyValue<T, K>,\n): NestedKeyValue<T, K> => {\n    if (!obj || !key) return undefined as NestedKeyValue<T, K>\n\n    const keyParts = key.split(\".\") as Array<keyof T>\n    let value = { ...obj }\n\n    for (const part of keyParts) {\n        value = (value as Record<keyof T, T>)?.[part as keyof T]\n        if (value === undefined) {\n            break\n        }\n    }\n    return (value || defaultValue) as NestedKeyValue<T, K>\n}\n\nexport default get\n","import { Children, isValidElement, PropsWithChildren, ReactElement, ReactNode } from 'react'\nimport {Nullable} from \"../../types/common\";\n\n\ninterface ShowProps {}\n\ninterface ChildProps {\n    isTrue?: boolean\n}\n\nconst Show = ({ children }: PropsWithChildren<ShowProps>) => {\n    let when: Nullable<ReactElement<ChildProps>> = null\n    let otherwise: Nullable<ReactElement<ChildProps>> = null\n\n    Children.forEach(children, (child) => {\n        if (!isValidElement<ChildProps>(child)) return\n\n        if (!child.props.isTrue) {\n            otherwise = child\n        } else if (child.props.isTrue && !when) {\n            when = child\n        }\n    })\n\n    return when || otherwise\n}\n\nShow.When = ({ children, isTrue }: PropsWithChildren<ChildProps>) => {\n    return isTrue && children\n}\nShow.Else = ({\n                 children,\n                 render\n             }: PropsWithChildren<\n    ChildProps & {\n    render?: ReactNode\n}\n>) => {\n    return render || children\n}\n\nexport default Show","import React, { Children, Fragment } from 'react'\nimport Show from \"../Show/Show\";\n\ninterface DataListProps<T> {\n    list: T[]\n    render: (item: T, index: number) => React.ReactNode\n    empty?: React.ReactNode\n}\n\nconst DataList = <T,>({ list, render, empty }: DataListProps<T>) => {\n    return (\n        <Fragment>\n            {\n                <Show>\n                    <Show.When isTrue={Array.isArray(list) && list.length > 0}>{Children.toArray(list.map(render))}</Show.When>\n                    <Show.Else>{empty}</Show.Else>\n                </Show>\n            }\n        </Fragment>\n    )\n}\n\nexport default DataList\n","import { get }  from \"../index\";\n\n\n\ntest('get one floor', () => {\n    const result = get({a :10}, \"a\");\n    expect(result).toBe(10);\n});\n\ntest('is undifined', () => {\n    const result = get(undefined!, \"a\");\n    expect(result).toBe(undefined);\n});\ntest('get function', () => {\n    const result = get({a :10, b :{z :1}}, \"b.z\");\n    expect(result).toBe(1);\n});"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAGA,IAAM,MAAM,CACR,KACA,KACA,iBACuB;AACvB,MAAI,CAAC,OAAO,CAAC,IAAK,QAAO;AAEzB,QAAM,WAAW,IAAI,MAAM,GAAG;AAC9B,MAAI,QAAQ,mBAAK;AAEjB,aAAW,QAAQ,UAAU;AACzB,YAAS,+BAA+B;AACxC,QAAI,UAAU,QAAW;AACrB;AAAA,IACJ;AAAA,EACJ;AACA,SAAQ,SAAS;AACrB;AAEA,IAAO,cAAQ;;;ACtBf,mBAAqF;AAUrF,IAAM,OAAO,CAAC,EAAE,SAAS,MAAoC;AACzD,MAAI,OAA2C;AAC/C,MAAI,YAAgD;AAEpD,wBAAS,QAAQ,UAAU,CAAC,UAAU;AAClC,QAAI,KAAC,6BAA2B,KAAK,EAAG;AAExC,QAAI,CAAC,MAAM,MAAM,QAAQ;AACrB,kBAAY;AAAA,IAChB,WAAW,MAAM,MAAM,UAAU,CAAC,MAAM;AACpC,aAAO;AAAA,IACX;AAAA,EACJ,CAAC;AAED,SAAO,QAAQ;AACnB;AAEA,KAAK,OAAO,CAAC,EAAE,UAAU,OAAO,MAAqC;AACjE,SAAO,UAAU;AACrB;AACA,KAAK,OAAO,CAAC;AAAA,EACI;AAAA,EACA;AACJ,MAIP;AACF,SAAO,UAAU;AACrB;;;ACvCA,IAAAA,gBAA0C;;;ACI1C,KAAK,iBAAiB,MAAM;AACxB,QAAM,SAAS,YAAI,EAAC,GAAG,GAAE,GAAG,GAAG;AAC/B,SAAO,MAAM,EAAE,KAAK,EAAE;AAC1B,CAAC;AAED,KAAK,gBAAgB,MAAM;AACvB,QAAM,SAAS,YAAI,QAAY,GAAG;AAClC,SAAO,MAAM,EAAE,KAAK,MAAS;AACjC,CAAC;AACD,KAAK,gBAAgB,MAAM;AACvB,QAAM,SAAS,YAAI,EAAC,GAAG,IAAI,GAAG,EAAC,GAAG,EAAC,EAAC,GAAG,KAAK;AAC5C,SAAO,MAAM,EAAE,KAAK,CAAC;AACzB,CAAC;","names":["import_react"]}