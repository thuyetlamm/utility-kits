var T=Object.defineProperty;var i=Object.getOwnPropertySymbols;var d=Object.prototype.hasOwnProperty,h=Object.prototype.propertyIsEnumerable;var y=(e,t,r)=>t in e?T(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[t]=r,p=(e,t)=>{for(var r in t||(t={}))d.call(t,r)&&y(e,r,t[r]);if(i)for(var r of i(t))h.call(t,r)&&y(e,r,t[r]);return e};var c=e=>{if(e===null||typeof e!="object")return e;if(Array.isArray(e)){let t=[];for(let r=0;r<e.length;r++)t[r]=c(e[r]);return t}if(e instanceof Object){let t={};for(let r in e)e.hasOwnProperty(r)&&(t[r]=c(e[r]));return t}throw new Error("Unable to copy object! Its type isn't supported.")},a=c;var l=(e,t)=>{if(!e||!t)return e!=null?e:t;let r=a(e),n=a(t);if(Array.isArray(r)&&Array.isArray(n))return[...r,...n];if(typeof e=="object"&&typeof t=="object"){let s=p({},r);for(let o in t)if(t.hasOwnProperty(o)){let u=r[o],f=n[o];n[o]instanceof Object&&o in r?s[o]=l(u,f):s[o]=f}return s}throw new Error("Both target and source should be either objects or arrays")},m=l;export{m as default};
//# sourceMappingURL=merge.mjs.map