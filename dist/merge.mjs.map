{"version":3,"sources":["../src/deepClone.ts","../src/merge.ts"],"sourcesContent":["const deepClone = <T>(obj: T): T => {\n    // Check if the value is null or not an object\n    if (obj === null || typeof obj !== \"object\") {\n        return obj\n    }\n\n    // Handle arrays\n    if (Array.isArray(obj)) {\n        const copy = []\n        for (let i = 0; i < obj.length; i++) {\n            copy[i] = deepClone(obj[i])\n        }\n        return copy as T\n    }\n\n    // Handle objects\n    if (obj instanceof Object) {\n        const copy = {} as T\n        for (const key in obj) {\n            if (obj.hasOwnProperty(key)) {\n                copy[key as keyof T] = deepClone(obj[key])\n            }\n        }\n        return copy as T\n    }\n\n    throw new Error(\"Unable to copy object! Its type isn't supported.\")\n}\nexport default deepClone\n","import deepClone  from \"./deepClone\"\nimport { MergeObject } from \"./types/merge\";\n\n\nconst merge = <T extends object>(target: T, source: T) => {\n    if (!target || !source) return target ?? source\n\n    const clonedTarget = deepClone(target)\n    const clonedSource = deepClone(source)\n\n    if (Array.isArray(clonedTarget) && Array.isArray(clonedSource)) {\n        return [...clonedTarget, ...clonedSource] as T\n    }\n\n    if (typeof target === \"object\" && typeof source === \"object\") {\n        const result: T = { ...clonedTarget } as T\n        for (const key in source) {\n            if (source.hasOwnProperty(key)) {\n                const targetValue = clonedTarget[key] // Store target value for potential recursion\n                const sourceValue = clonedSource[key]\n                if (clonedSource[key] instanceof Object && key in clonedTarget) {\n                    result[key] = merge(\n                        targetValue as MergeObject<typeof targetValue>,\n                        sourceValue as MergeObject<typeof sourceValue>,\n                    )\n                } else {\n                    result[key] = sourceValue\n                }\n            }\n        }\n        return result\n    }\n\n    throw new Error(\"Both target and source should be either objects or arrays\")\n}\n\nexport default merge\n"],"mappings":"yVAAA,IAAMA,EAAgBC,GAAc,CAEhC,GAAIA,IAAQ,MAAQ,OAAOA,GAAQ,SAC/B,OAAOA,EAIX,GAAI,MAAM,QAAQA,CAAG,EAAG,CACpB,IAAMC,EAAO,CAAC,EACd,QAASC,EAAI,EAAGA,EAAIF,EAAI,OAAQE,IAC5BD,EAAKC,CAAC,EAAIH,EAAUC,EAAIE,CAAC,CAAC,EAE9B,OAAOD,CACX,CAGA,GAAID,aAAe,OAAQ,CACvB,IAAMC,EAAO,CAAC,EACd,QAAWE,KAAOH,EACVA,EAAI,eAAeG,CAAG,IACtBF,EAAKE,CAAc,EAAIJ,EAAUC,EAAIG,CAAG,CAAC,GAGjD,OAAOF,CACX,CAEA,MAAM,IAAI,MAAM,kDAAkD,CACtE,EACOG,EAAQL,ECxBf,IAAMM,EAAQ,CAAmBC,EAAWC,IAAc,CACtD,GAAI,CAACD,GAAU,CAACC,EAAQ,OAAOD,GAAA,KAAAA,EAAUC,EAEzC,IAAMC,EAAeC,EAAUH,CAAM,EAC/BI,EAAeD,EAAUF,CAAM,EAErC,GAAI,MAAM,QAAQC,CAAY,GAAK,MAAM,QAAQE,CAAY,EACzD,MAAO,CAAC,GAAGF,EAAc,GAAGE,CAAY,EAG5C,GAAI,OAAOJ,GAAW,UAAY,OAAOC,GAAW,SAAU,CAC1D,IAAMI,EAAYC,EAAA,GAAKJ,GACvB,QAAWK,KAAON,EACd,GAAIA,EAAO,eAAeM,CAAG,EAAG,CAC5B,IAAMC,EAAcN,EAAaK,CAAG,EAC9BE,EAAcL,EAAaG,CAAG,EAChCH,EAAaG,CAAG,YAAa,QAAUA,KAAOL,EAC9CG,EAAOE,CAAG,EAAIR,EACVS,EACAC,CACJ,EAEAJ,EAAOE,CAAG,EAAIE,CAEtB,CAEJ,OAAOJ,CACX,CAEA,MAAM,IAAI,MAAM,2DAA2D,CAC/E,EAEOK,EAAQX","names":["deepClone","obj","copy","i","key","deepClone_default","merge","target","source","clonedTarget","deepClone_default","clonedSource","result","__spreadValues","key","targetValue","sourceValue","merge_default"]}