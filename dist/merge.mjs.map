{"version":3,"sources":["../src/deepClone.ts","../src/merge.ts"],"sourcesContent":["const deepClone = <T>(obj: T): T => {\n    // Check if the value is null or not an object\n    if (obj === null || typeof obj !== \"object\") {\n        return obj\n    }\n\n    // Handle arrays\n    if (Array.isArray(obj)) {\n        const copy = []\n        for (let i = 0; i < obj.length; i++) {\n            copy[i] = deepClone(obj[i])\n        }\n        return copy as T\n    }\n\n    // Handle objects\n    if (obj instanceof Object) {\n        const copy = {} as T\n        for (const key in obj) {\n            if (obj.hasOwnProperty(key)) {\n                copy[key as keyof T] = deepClone(obj[key])\n            }\n        }\n        return copy as T\n    }\n\n    throw new Error(\"Unable to copy object! Its type isn't supported.\")\n}\nexport default deepClone\n","import deepClone  from \"./deepClone\"\n\ntype MergeableObject<T> = T extends object ? T : never\n\nconst merge = <T extends object>(target: T, source: T) => {\n    if (!target || !source) return target ?? source\n\n    const clonedTarget = deepClone(target)\n    const clonedSource = deepClone(source)\n\n    if (Array.isArray(clonedTarget) && Array.isArray(clonedSource)) {\n        return [...clonedTarget, ...clonedSource] as T\n    }\n\n    if (typeof target === \"object\" && typeof source === \"object\") {\n        const result: T = { ...clonedTarget } as T\n        for (const key in source) {\n            if (source.hasOwnProperty(key)) {\n                const targetValue = clonedTarget[key] // Store target value for potential recursion\n                const sourceValue = clonedSource[key]\n                if (clonedSource[key] instanceof Object && key in clonedTarget) {\n                    result[key] = merge(\n                        targetValue as MergeableObject<typeof targetValue>,\n                        sourceValue as MergeableObject<typeof sourceValue>,\n                    )\n                } else {\n                    result[key] = sourceValue\n                }\n            }\n        }\n        return result\n    }\n\n    throw new Error(\"Both target and source should be either objects or arrays\")\n}\n\nexport default merge\n"],"mappings":";;;;;;;;;;;;;;;;;;AAAA,IAAM,YAAY,CAAI,QAAc;AAEhC,MAAI,QAAQ,QAAQ,OAAO,QAAQ,UAAU;AACzC,WAAO;AAAA,EACX;AAGA,MAAI,MAAM,QAAQ,GAAG,GAAG;AACpB,UAAM,OAAO,CAAC;AACd,aAAS,IAAI,GAAG,IAAI,IAAI,QAAQ,KAAK;AACjC,WAAK,CAAC,IAAI,UAAU,IAAI,CAAC,CAAC;AAAA,IAC9B;AACA,WAAO;AAAA,EACX;AAGA,MAAI,eAAe,QAAQ;AACvB,UAAM,OAAO,CAAC;AACd,eAAW,OAAO,KAAK;AACnB,UAAI,IAAI,eAAe,GAAG,GAAG;AACzB,aAAK,GAAc,IAAI,UAAU,IAAI,GAAG,CAAC;AAAA,MAC7C;AAAA,IACJ;AACA,WAAO;AAAA,EACX;AAEA,QAAM,IAAI,MAAM,kDAAkD;AACtE;AACA,IAAO,oBAAQ;;;ACxBf,IAAM,QAAQ,CAAmB,QAAW,WAAc;AACtD,MAAI,CAAC,UAAU,CAAC,OAAQ,QAAO,0BAAU;AAEzC,QAAM,eAAe,kBAAU,MAAM;AACrC,QAAM,eAAe,kBAAU,MAAM;AAErC,MAAI,MAAM,QAAQ,YAAY,KAAK,MAAM,QAAQ,YAAY,GAAG;AAC5D,WAAO,CAAC,GAAG,cAAc,GAAG,YAAY;AAAA,EAC5C;AAEA,MAAI,OAAO,WAAW,YAAY,OAAO,WAAW,UAAU;AAC1D,UAAM,SAAY,mBAAK;AACvB,eAAW,OAAO,QAAQ;AACtB,UAAI,OAAO,eAAe,GAAG,GAAG;AAC5B,cAAM,cAAc,aAAa,GAAG;AACpC,cAAM,cAAc,aAAa,GAAG;AACpC,YAAI,aAAa,GAAG,aAAa,UAAU,OAAO,cAAc;AAC5D,iBAAO,GAAG,IAAI;AAAA,YACV;AAAA,YACA;AAAA,UACJ;AAAA,QACJ,OAAO;AACH,iBAAO,GAAG,IAAI;AAAA,QAClB;AAAA,MACJ;AAAA,IACJ;AACA,WAAO;AAAA,EACX;AAEA,QAAM,IAAI,MAAM,2DAA2D;AAC/E;AAEA,IAAO,gBAAQ;","names":[]}