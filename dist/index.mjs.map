{"version":3,"sources":["../src/get.ts","../src/checkTypes.ts","../src/deepClone.ts","../src/isEmpty.ts","../src/merge.ts","../src/components/Show/Show.tsx","../src/components/Each/Each.tsx","../src/utils/isKey.ts","../src/utils/memoize.ts","../src/utils/memoizeCapped.ts","../src/utils/stringToPath.ts","../src/utils/cashPath.ts","../src/utils/isIndex.ts","../src/utils/assignValue.ts","../src/utils/baseSet.ts","../src/set.ts"],"sourcesContent":["import { NestedKeyOf, NestedKeyValue } from \"./types/get\";\n\n\nconst get = <T extends object, K extends NestedKeyOf<T> = NestedKeyOf<T>>(\n    obj: T,\n    key: K,\n    defaultValue?: NestedKeyValue<T, K>,\n):  NestedKeyValue<T, K> => {\n    if (!obj || !key) return undefined as NestedKeyValue<T, K>\n\n\n    const keyParts = key.split(\".\") as Array<keyof T>\n    let value = { ...obj }\n\n    for (const part of keyParts) {\n        value = (value as Record<keyof T, T>)?.[part as keyof T]\n        if (value === undefined) {\n            break\n        }\n    }\n    return (value || defaultValue) as NestedKeyValue<T, K>\n}\n\nexport default get\n\n","import { DATATYPE } from \"./types/common\"\n\nconst checkType = <T>(value:T)  =>\n    Object.prototype.toString.call(value).slice(8, -1) as DATATYPE\n\nexport const isObject = <T>(value: T) => checkType(value) === DATATYPE.Object\nexport const isArray  = <T>(value: T) => checkType(value) === DATATYPE.Array\nexport const isNaN    = <T>(value: T) => checkType(value) === DATATYPE.NaN\nexport const isFunction = <T>(value: T) => checkType(value) === DATATYPE.Function\nexport const isNumber = <T>(value: T) => checkType(value) === DATATYPE.Number\nexport const isString = <T>(value: T) => checkType(value) === DATATYPE.String\nexport const isSymbol = <T>(value: T) => checkType(value) === DATATYPE.Symbol\nexport const isNull   = <T>(value: T) => checkType(value) === DATATYPE.Null\nexport const isUndefined   = <T>(value: T) => checkType(value) === DATATYPE.Undefined\n\nconst checkTypeInstance = {\n    isObject,\n    isArray,\n    isNaN,\n    isFunction,\n    checkType,\n    isString,\n    isNumber,\n    isSymbol,\n    isNull,\n    isUndefined\n}\nexport default checkTypeInstance\n\n","const deepClone = <T>(obj: T): T => {\n    // Check if the value is null or not an object\n    if (obj === null || typeof obj !== \"object\") {\n        return obj\n    }\n\n    // Handle arrays\n    if (Array.isArray(obj)) {\n        const copy = []\n        for (let i = 0; i < obj.length; i++) {\n            copy[i] = deepClone(obj[i])\n        }\n        return copy as T\n    }\n\n    // Handle objects\n    if (obj instanceof Object) {\n        const copy = {} as T\n        for (const key in obj) {\n            if (obj.hasOwnProperty(key)) {\n                copy[key as keyof T] = deepClone(obj[key])\n            }\n        }\n        return copy as T\n    }\n\n    throw new Error(\"Unable to copy object! Its type isn't supported.\")\n}\nexport default deepClone\n","import {checkTypes} from \"./index\";\n\nconst isEmpty = <T>(val: T) => {\n\n    if(!val) return true;\n\n    // Check for an empty array\n    if(checkTypes.isArray(val) && val instanceof Array) {\n        return !val.length;\n    }\n    // Check for an empty string or array\n\n    if (checkTypes.isString(val) && val instanceof String) return !(val.trim().length === 0)\n\n    // Check for an empty Map or Set\n\n    if(val instanceof Map || val instanceof Set) {\n        return !val.size\n    }\n\n    return !Object.keys(val ?? {}).length\n}\nexport default isEmpty\n","import deepClone  from \"./deepClone\"\nimport { MergeObject } from \"./types/merge\";\n\n\nconst merge = <T extends object>(target: T, source: T) => {\n    if (!target || !source) return target ?? source\n\n    const clonedTarget = deepClone(target)\n    const clonedSource = deepClone(source)\n\n    if (Array.isArray(clonedTarget) && Array.isArray(clonedSource)) {\n        return [...clonedTarget, ...clonedSource] as T\n    }\n\n    if (typeof target === \"object\" && typeof source === \"object\") {\n        const result: T = { ...clonedTarget } as T\n        for (const key in source) {\n            if (source.hasOwnProperty(key)) {\n                const targetValue = clonedTarget[key] // Store target value for potential recursion\n                const sourceValue = clonedSource[key]\n                if (clonedSource[key] instanceof Object && key in clonedTarget) {\n                    result[key] = merge(\n                        targetValue as MergeObject<typeof targetValue>,\n                        sourceValue as MergeObject<typeof sourceValue>,\n                    )\n                } else {\n                    result[key] = sourceValue\n                }\n            }\n        }\n        return result\n    }\n\n    throw new Error(\"Both target and source should be either objects or arrays\")\n}\n\nexport default merge\n","import { Children, isValidElement, PropsWithChildren, ReactElement, ReactNode } from 'react'\nimport {Nullable} from \"../../types/common\";\n\n\ninterface ShowProps {}\n\ninterface ChildProps {\n    isTrue?: boolean\n}\n\nconst Show = ({ children }: PropsWithChildren<ShowProps>) => {\n    let when: Nullable<ReactElement<ChildProps>> = null\n    let otherwise: Nullable<ReactElement<ChildProps>> = null\n\n    Children.forEach(children, (child) => {\n        if (!isValidElement<ChildProps>(child)) return\n\n        if (!child.props.isTrue) {\n            otherwise = child\n        } else if (child.props.isTrue && !when) {\n            when = child\n        }\n    })\n\n    return when || otherwise\n}\n\nShow.When = ({ children, isTrue }: PropsWithChildren<ChildProps>) => {\n    return isTrue && children\n}\nShow.Else = ({\n                 children,\n                 render\n             }: PropsWithChildren<\n    ChildProps & {\n    render?: ReactNode\n}\n>) => {\n    return render || children\n}\n\nexport default Show","import React, { Children, Fragment } from 'react'\nimport Show from \"../Show/Show\";\n\ninterface EachProps<T> {\n    list: T[] | readonly T[];\n    render: (item: T, index: number) => React.ReactNode\n    empty?: React.ReactNode\n}\n\nconst Each = <T,>({ list, render, empty }: EachProps<T>) => {\n    return (\n        <Fragment>\n            {\n                <Show>\n                    <Show.When isTrue={Array.isArray(list) && list.length > 0}>{Children.toArray(list.map(render))}</Show.When>\n                    <Show.Else>{empty}</Show.Else>\n                </Show>\n            }\n        </Fragment>\n    )\n}\n\nexport default Each\n\n\n","import {checkTypes} from \"../index\";\nimport {DATATYPE} from \"../types/common\";\n\n/** Used to match property names within property paths. */\nconst reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/\nconst reIsPlainProp = /^\\w*$/\n\n/**\n * Checks if `value` is a property name and not a property path.\n *\n */\nconst isKey = <T extends string>(value :T, object : object): boolean => {\n    if (Array.isArray(value)) {\n        return false\n    }\n\n    if([DATATYPE.Number,DATATYPE.Boolean,DATATYPE.Null,DATATYPE.Symbol].includes(checkTypes.checkType(value))) {\n        return true\n    }\n    return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\n        (object != null && value in Object(object))\n}\n\nexport default isKey","import {checkTypes} from \"../index\";\n\n/**\n * Creates a function that memoizes the result of `func`. If `resolver` is\n * provided, it determines the cache key for storing the result based on the\n * arguments provided to the memoized function. By default, the first argument\n * provided to the memoized function is used as the map cache key. The `func`\n * is invoked with the `this` binding of the memoized function.\n *\n * **Note:** The cache is exposed as the `cache` property on the memoized\n * function. Its creation may be customized by replacing the `memoize.Cache`\n * constructor with one whose instances implement the\n * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n * method interface of `clear`, `delete`, `get`, `has`, and `set`.\n *\n*/\nexport type TKey =  [key?: TKey, ...rest: any[]]\nexport type TFunction = (...args:  TKey) => string[]\nexport type MemFunction = TFunction & {\n    cache? :Map<any,any>\n};\n\nconst memoize = (func:TFunction, resolver :TFunction) => {\n    if (!checkTypes.isFunction(func) || !checkTypes.isFunction(resolver)) {\n        throw new TypeError('Expected a function');\n    }\n    const memoized = (...args: TKey) => {\n        const key = resolver ? resolver.apply(null, args) : args[0];\n        const cache = memoized.cache as Map<any,any>;\n\n        if (cache.has(key)) {\n            return cache.get(key);\n        }\n        const result = func.apply(null, args);\n        memoized.cache = cache.set(key, result) || cache;\n        return result;\n    };\n    memoized.cache = new (memoize.Cache || Map)();\n    return memoized;\n}\n\nmemoize.Cache = Map;\n\nexport default memoize;","import memoize, {MemFunction, TFunction, TKey} from \"./memoize\";\n\n/** Used as the maximum memoize cache size. */\nconst MAX_MEMOIZE_SIZE = 500\n\n/**\n * A specialized version of `memoize` which clears the memoized function's\n * cache when it exceeds `MAX_MEMOIZE_SIZE`.\n */\nconst memoizeCapped = <T extends MemFunction>(func: TFunction) : T => {\n    const result = memoize(func, (...key : TKey) : string[] => {\n        const { cache } = result\n        if (cache?.size === MAX_MEMOIZE_SIZE) {\n            cache?.clear()\n        }\n        return key\n    }) as T\n\n    return result\n}\n\nexport default memoizeCapped","import memoizeCapped from './memoizeCapped'\nimport {checkTypes} from \"../index\";\n\nconst charCodeOfDot = '.'.charCodeAt(0)\nconst reEscapeChar = /\\\\(\\\\)?/g\nconst rePropName = RegExp(\n    // Match anything that isn't a dot or bracket.\n    '[^.[\\\\]]+' + '|' +\n    // Or match property names within brackets.\n    '\\\\[(?:' +\n    // Match a non-string expression.\n    '([^\"\\'][^[]*)' + '|' +\n    // Or match strings (supports escaping characters).\n    '([\"\\'])((?:(?!\\\\2)[^\\\\\\\\]|\\\\\\\\.)*?)\\\\2' +\n    ')\\\\]'+ '|' +\n    // Or match \"\" as the space between consecutive dots or empty brackets.\n    '(?=(?:\\\\.|\\\\[\\\\])(?:\\\\.|\\\\[\\\\]|$))'\n    , 'g')\n\nconst stringToPath = memoizeCapped((str?: string | string[]) : string[]  => {\n    const result : string[] = []\n    if(!checkTypes.isString(str)) return result\n    if ((str as string)?.charCodeAt(0) === charCodeOfDot) {\n        result.push('')\n    }\n    (str as string)?.replace(rePropName, (match: string, expression?: string, quote?: string, subString?: string) : any   => {\n        let key = match\n        if (quote) {\n            key = subString?.replace(reEscapeChar, '$1') ?? ''\n        }\n        else if (expression) {\n            key = expression.trim()\n        }\n        result.push(key)\n    })\n    return result\n})\n\nexport default stringToPath","import isKey from \"./isKey\";\nimport stringToPath from \"./stringToPath\";\nimport {TKey} from \"./memoize\";\n\n\nfunction castPath<T extends TKey>(value :T, object : object) : T | T[] {\n    if (Array.isArray(value)) {\n        return value\n    }\n    return isKey(value, object) ? [value] : stringToPath(value) as any\n}\n\nexport default castPath","import {checkTypes} from \"../index\";\n\n/** Used as references for various `Number` constants. */\nconst MAX_SAFE_INTEGER = 9007199254740991\n\n/** Used to detect unsigned integer values. */\nconst reIsUint = /^(?:0|[1-9]\\d*)$/\n\n\nfunction isIndex<T extends string | symbol | number>(value :T, length : number = MAX_SAFE_INTEGER) : boolean {\n\n    return !!length &&\n        (checkTypes.isNumber(value as number) ||\n            (!checkTypes.isSymbol(value as string) && reIsUint.test(value as string))) &&\n        (Number(value) > -1 && Number(value) % 1 === 0 && Number(value) < length)\n}\n\n\nexport default isIndex","\n/** Used to check objects for own properties. */\nconst hasOwnProperty = Object.prototype.hasOwnProperty\n\n/**\n * Assigns `value` to `key` of `object` if the existing value is not equivalent.\n */\n\nfunction baseAssignValue<T extends object,K extends keyof T>(object : T, key:K, value: T[K]) {\n    if (key === '__proto__') {\n        Object.defineProperty(object, key, {\n            'configurable': true,\n            'enumerable': true,\n            'value': value,\n            'writable': true\n        })\n    } else {\n        object[key] = value\n    }\n}\n\nfunction eq<T>(value :T, other :T) {\n    return value === other || (value !== value && other !== other);\n}\n\n\nfunction assignValue<T extends object,K extends keyof T>(object :T, key : K, value : T[K]) {\n    const objValue = object[key]\n\n    if (!(hasOwnProperty.call(object, key) && eq(objValue, value))) {\n        if (value !== 0 || (1 / Number(value)) === (1 / Number(objValue))) {\n            baseAssignValue(object, key, value)\n        }\n    } else if (value === undefined && !(key in object)) {\n        baseAssignValue(object, key, value)\n    }\n}\n\nexport default assignValue","import castPath from \"./cashPath\";\nimport {checkTypes} from \"../index\";\nimport isIndex from \"./isIndex\";\nimport assignValue from \"./assignValue\";\nimport {DATATYPE} from \"../types/common\";\nimport {NestedKeyOf, NestedKeyValue} from \"../types/get\";\n\n\nconst INFINITY = 1 / 0\n\nfunction toKey<T>(value : T) {\n    if ([DATATYPE.Symbol,DATATYPE.String].includes(checkTypes.checkType(value))) {\n        return value\n    }\n    const result = `${value}`\n    return (result === '0' && (1 / Number(value)) === -INFINITY) ? '-0' : result\n}\n\n\nfunction baseSet<T extends object,K extends NestedKeyOf<T>>(object : T, path : K, value : NestedKeyValue<T, K>) {\n    if (!checkTypes.isObject(object)) {\n        return object\n    }\n    path = castPath(path as any, object)\n       const length = path.length\n    const lastIndex = length - 1\n\n    let index = -1\n    let nested = object\n\n    while (nested != null && ++index < length) {\n        const key = toKey(path[index])\n        let newValue = value\n\n        if (index !== lastIndex) {\n            const objValue = nested[key as keyof T]\n                newValue = checkTypes.isObject(objValue)\n                    ? objValue as NestedKeyValue<T, K>\n                    : (isIndex(path[index + 1]) ? [] : {}) as NestedKeyValue<T, K>\n\n        }\n        assignValue(nested, key as any, newValue)\n        nested = nested[key as keyof T] as T\n    }\n    return object\n}\n\nexport default baseSet","import { checkTypes } from   \"./index\"\nimport {NestedKeyOf, NestedKeyValue} from \"./types/get\";\nimport baseSet from \"./utils/baseSet\";\n\n\n\nconst set = <T extends object,K extends NestedKeyOf<T>>(object : T, path : K, value :NestedKeyValue<T, K>) =>  {\n    if(!object || !checkTypes.isObject(object)) return object\n    return checkTypes.isNull(object) ? object : baseSet(object, path as any, value);\n}\n\n\nexport default set;"],"mappings":"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","names":["Children","Children"]}