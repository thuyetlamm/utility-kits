{"version":3,"sources":["../src/get.ts","../src/checkTypes.ts","../src/deepClone.ts","../src/isEmpty.ts","../src/merge.ts","../src/components/Show/Show.tsx","../src/components/Each/Each.tsx"],"sourcesContent":["import {NestedKeyOf, NestedKeyValue} from \"./types/get\";\n\n\nconst get = <T extends object, K extends NestedKeyOf<T>>(\n    obj: T,\n    key: K,\n    defaultValue?: NestedKeyValue<T, K>,\n): NestedKeyValue<T, K> => {\n    if (!obj || !key) return undefined as NestedKeyValue<T, K>\n\n    const keyParts = key.split(\".\") as Array<keyof T>\n    let value = { ...obj }\n\n    for (const part of keyParts) {\n        value = (value as Record<keyof T, T>)?.[part as keyof T]\n        if (value === undefined) {\n            break\n        }\n    }\n    return (value || defaultValue) as NestedKeyValue<T, K>\n}\n\nexport default get\n","import { DATATYPE } from \"./types/common\"\n\nconst checkType = (value: object | number | string) =>\n    Object.prototype.toString.call(value).slice(8, -1)\n\nconst isObject = (value: object) => checkType(value) === DATATYPE.Object\nconst isArray = (value: object) => checkType(value) === DATATYPE.Array\nconst isNaN = (value: number) => checkType(value) === DATATYPE.NaN\nconst isFunction = (value: object) => checkType(value) === DATATYPE.Function\nconst isNumber = (value: number) => checkType(value) === DATATYPE.Number\nconst isString= (value: string) => checkType(value) === DATATYPE.String\n\nconst checkTypeInstance = {\n    isObject,\n    isArray,\n    isNaN,\n    isFunction,\n    checkType,\n    isString,\n    isNumber\n}\nexport default checkTypeInstance\n\n","const deepClone = <T>(obj: T): T => {\n    // Check if the value is null or not an object\n    if (obj === null || typeof obj !== \"object\") {\n        return obj\n    }\n\n    // Handle arrays\n    if (Array.isArray(obj)) {\n        const copy = []\n        for (let i = 0; i < obj.length; i++) {\n            copy[i] = deepClone(obj[i])\n        }\n        return copy as T\n    }\n\n    // Handle objects\n    if (obj instanceof Object) {\n        const copy = {} as T\n        for (const key in obj) {\n            if (obj.hasOwnProperty(key)) {\n                copy[key as keyof T] = deepClone(obj[key])\n            }\n        }\n        return copy as T\n    }\n\n    throw new Error(\"Unable to copy object! Its type isn't supported.\")\n}\nexport default deepClone\n","const isEmpty = <T>(obj: T) => {\n    // Check for an empty string\n    if (typeof obj === \"string\" && obj.trim().length === 0) return true\n    return !Object.keys(obj ?? {}).length\n}\nexport default isEmpty\n","import deepClone  from \"./deepClone\"\nimport { MergeObject } from \"./types/merge\";\n\n\nconst merge = <T extends object>(target: T, source: T) => {\n    if (!target || !source) return target ?? source\n\n    const clonedTarget = deepClone(target)\n    const clonedSource = deepClone(source)\n\n    if (Array.isArray(clonedTarget) && Array.isArray(clonedSource)) {\n        return [...clonedTarget, ...clonedSource] as T\n    }\n\n    if (typeof target === \"object\" && typeof source === \"object\") {\n        const result: T = { ...clonedTarget } as T\n        for (const key in source) {\n            if (source.hasOwnProperty(key)) {\n                const targetValue = clonedTarget[key] // Store target value for potential recursion\n                const sourceValue = clonedSource[key]\n                if (clonedSource[key] instanceof Object && key in clonedTarget) {\n                    result[key] = merge(\n                        targetValue as MergeObject<typeof targetValue>,\n                        sourceValue as MergeObject<typeof sourceValue>,\n                    )\n                } else {\n                    result[key] = sourceValue\n                }\n            }\n        }\n        return result\n    }\n\n    throw new Error(\"Both target and source should be either objects or arrays\")\n}\n\nexport default merge\n","import { Children, isValidElement, PropsWithChildren, ReactElement, ReactNode } from 'react'\nimport {Nullable} from \"../../types/common\";\n\n\ninterface ShowProps {}\n\ninterface ChildProps {\n    isTrue?: boolean\n}\n\nconst Show = ({ children }: PropsWithChildren<ShowProps>) => {\n    let when: Nullable<ReactElement<ChildProps>> = null\n    let otherwise: Nullable<ReactElement<ChildProps>> = null\n\n    Children.forEach(children, (child) => {\n        if (!isValidElement<ChildProps>(child)) return\n\n        if (!child.props.isTrue) {\n            otherwise = child\n        } else if (child.props.isTrue && !when) {\n            when = child\n        }\n    })\n\n    return when || otherwise\n}\n\nShow.When = ({ children, isTrue }: PropsWithChildren<ChildProps>) => {\n    return isTrue && children\n}\nShow.Else = ({\n                 children,\n                 render\n             }: PropsWithChildren<\n    ChildProps & {\n    render?: ReactNode\n}\n>) => {\n    return render || children\n}\n\nexport default Show","import React, { Children, Fragment } from 'react'\nimport Show from \"../Show/Show\";\n\ninterface DataListProps<T> {\n    list: T[]\n    render: (item: T, index: number) => React.ReactNode\n    empty?: React.ReactNode\n}\n\nconst DataList = <T,>({ list, render, empty }: DataListProps<T>) => {\n    return (\n        <Fragment>\n            {\n                <Show>\n                    <Show.When isTrue={Array.isArray(list) && list.length > 0}>{Children.toArray(list.map(render))}</Show.When>\n                    <Show.Else>{empty}</Show.Else>\n                </Show>\n            }\n        </Fragment>\n    )\n}\n\nexport default DataList\n"],"mappings":"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","names":["Children","Children"]}