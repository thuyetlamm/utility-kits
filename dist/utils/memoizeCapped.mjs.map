{"version":3,"sources":["../../src/checkTypes.ts","../../src/utils/memoize.ts","../../src/utils/memoizeCapped.ts"],"sourcesContent":["import { DATATYPE } from \"./types/common\"\n\nexport const checkType = <T>(value:T)  =>\n    Object.prototype.toString.call(value).slice(8, -1) as DATATYPE\n\nexport const isObject = <T>(value: T) => checkType(value) === DATATYPE.Object\nexport const isArray  = <T>(value: T) => checkType(value) === DATATYPE.Array\nexport const isNaN    = <T>(value: T) => checkType(value) === DATATYPE.NaN\nexport const isFunction = <T>(value: T) => checkType(value) === DATATYPE.Function\nexport const isNumber = <T>(value: T) => checkType(value) === DATATYPE.Number\nexport const isString = <T>(value: T) => checkType(value) === DATATYPE.String\nexport const isSymbol = <T>(value: T) => checkType(value) === DATATYPE.Symbol\nexport const isNull   = <T>(value: T) => checkType(value) === DATATYPE.Null\nexport const isUndefined   = <T>(value: T) => checkType(value) === DATATYPE.Undefined\n\nconst checkTypeInstance = {\n    isObject,\n    isArray,\n    isNaN,\n    isFunction,\n    checkType,\n    isString,\n    isNumber,\n    isSymbol,\n    isNull,\n    isUndefined\n}\nexport default checkTypeInstance\n\n","import { isFunction } from \"../checkTypes\";\n\n/**\n * Creates a function that memoizes the result of `func`. If `resolver` is\n * provided, it determines the cache key for storing the result based on the\n * arguments provided to the memoized function. By default, the first argument\n * provided to the memoized function is used as the map cache key. The `func`\n * is invoked with the `this` binding of the memoized function.\n *\n * **Note:** The cache is exposed as the `cache` property on the memoized\n * function. Its creation may be customized by replacing the `memoize.Cache`\n * constructor with one whose instances implement the\n * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n * method interface of `clear`, `delete`, `get`, `has`, and `set`.\n *\n*/\nexport type TKey =  [key?: TKey, ...rest: any[]]\nexport type TFunction = (...args:  TKey) => string[]\nexport type MemFunction = TFunction & {\n    cache? :Map<any,any>\n};\n\nconst memoize = (func:TFunction, resolver :TFunction) => {\n    if (!isFunction(func) || !isFunction(resolver)) {\n        throw new TypeError('Expected a function');\n    }\n    const memoized = (...args: TKey) => {\n        const key = resolver ? resolver.apply(null, args) : args[0];\n        const cache = memoized.cache as Map<any,any>;\n\n        if (cache.has(key)) {\n            return cache.get(key);\n        }\n        const result = func.apply(null, args);\n        memoized.cache = cache.set(key, result) || cache;\n        return result;\n    };\n    memoized.cache = new (memoize.Cache || Map)();\n    return memoized;\n}\n\nmemoize.Cache = Map;\n\nexport default memoize;","import memoize, {MemFunction, TFunction, TKey} from \"./memoize\";\n\n/** Used as the maximum memoize cache size. */\nconst MAX_MEMOIZE_SIZE = 500\n\n/**\n * A specialized version of `memoize` which clears the memoized function's\n * cache when it exceeds `MAX_MEMOIZE_SIZE`.\n */\nconst memoizeCapped = <T extends MemFunction>(func: TFunction) : T => {\n    const result = memoize(func, (...key : TKey) : string[] => {\n        const { cache } = result\n        if (cache?.size === MAX_MEMOIZE_SIZE) {\n            cache?.clear()\n        }\n        return key\n    }) as T\n\n    return result\n}\n\nexport default memoizeCapped"],"mappings":"AAEO,IAAMA,EAAgBC,GACzB,OAAO,UAAU,SAAS,KAAKA,CAAK,EAAE,MAAM,EAAG,EAAE,EAK9C,IAAMC,EAAiBC,GAAaC,EAAUD,CAAK,IAAM,WCchE,IAAME,EAAU,CAACC,EAAgBC,IAAwB,CACrD,GAAI,CAACC,EAAWF,CAAI,GAAK,CAACE,EAAWD,CAAQ,EACzC,MAAM,IAAI,UAAU,qBAAqB,EAE7C,IAAME,EAAW,IAAIC,IAAe,CAChC,IAAMC,EAAMJ,EAAWA,EAAS,MAAM,KAAMG,CAAI,EAAIA,EAAK,CAAC,EACpDE,EAAQH,EAAS,MAEvB,GAAIG,EAAM,IAAID,CAAG,EACb,OAAOC,EAAM,IAAID,CAAG,EAExB,IAAME,EAASP,EAAK,MAAM,KAAMI,CAAI,EACpC,OAAAD,EAAS,MAAQG,EAAM,IAAID,EAAKE,CAAM,GAAKD,EACpCC,CACX,EACA,OAAAJ,EAAS,MAAQ,IAAKJ,EAAQ,OAAS,KAChCI,CACX,EAEAJ,EAAQ,MAAQ,IAEhB,IAAOS,EAAQT,ECxCf,IAAMU,EAAmB,IAMnBC,EAAwCC,GAAwB,CAClE,IAAMC,EAASC,EAAQF,EAAM,IAAIG,IAA0B,CACvD,GAAM,CAAE,MAAAC,CAAM,EAAIH,EAClB,OAAIG,GAAA,YAAAA,EAAO,QAASN,IAChBM,GAAA,MAAAA,EAAO,SAEJD,CACX,CAAC,EAED,OAAOF,CACX,EAEOI,EAAQN","names":["checkType","value","isFunction","value","checkType","memoize","func","resolver","isFunction","memoized","args","key","cache","result","memoize_default","MAX_MEMOIZE_SIZE","memoizeCapped","func","result","memoize_default","key","cache","memoizeCapped_default"]}