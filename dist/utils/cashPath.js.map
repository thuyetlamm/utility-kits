{"version":3,"sources":["../../src/utils/cashPath.ts","../../src/checkTypes.ts","../../src/utils/isKey.ts","../../src/utils/memoize.ts","../../src/utils/memoizeCapped.ts","../../src/utils/stringToPath.ts"],"sourcesContent":["import isKey from \"./isKey\";\nimport stringToPath from \"./stringToPath\";\nimport {TKey} from \"./memoize\";\n\n\nfunction castPath<T extends TKey>(value :T, object : object) : T | T[] {\n    if (Array.isArray(value)) {\n        return value\n    }\n    return isKey(value, object) ? [value] : stringToPath(value) as any\n}\n\nexport default castPath","import { DATATYPE } from \"./types/common\"\n\nexport const checkType = <T>(value:T)  =>\n    Object.prototype.toString.call(value).slice(8, -1) as DATATYPE\n\nexport const isObject = <T>(value: T) => checkType(value) === DATATYPE.Object\nexport const isArray  = <T>(value: T) => checkType(value) === DATATYPE.Array\nexport const isNaN    = <T>(value: T) => checkType(value) === DATATYPE.NaN\nexport const isFunction = <T>(value: T) => checkType(value) === DATATYPE.Function\nexport const isNumber = <T>(value: T) => checkType(value) === DATATYPE.Number\nexport const isString = <T>(value: T) => checkType(value) === DATATYPE.String\nexport const isSymbol = <T>(value: T) => checkType(value) === DATATYPE.Symbol\nexport const isNull   = <T>(value: T) => checkType(value) === DATATYPE.Null\nexport const isUndefined   = <T>(value: T) => checkType(value) === DATATYPE.Undefined\n\nconst checkTypeInstance = {\n    isObject,\n    isArray,\n    isNaN,\n    isFunction,\n    checkType,\n    isString,\n    isNumber,\n    isSymbol,\n    isNull,\n    isUndefined\n}\nexport default checkTypeInstance\n\n","import {DATATYPE} from \"../types/common\";\nimport { checkType } from \"../checkTypes\";\n\n/** Used to match property names within property paths. */\nconst reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/\nconst reIsPlainProp = /^\\w*$/\n\n/**\n * Checks if `value` is a property name and not a property path.\n *\n */\nconst isKey = <T extends string>(value :T, object : object): boolean => {\n    if (Array.isArray(value)) {\n        return false\n    }\n\n    if([DATATYPE.Number,DATATYPE.Boolean,DATATYPE.Null,DATATYPE.Symbol].includes(checkType(value))) {\n        return true\n    }\n    return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\n        (object != null && value in Object(object))\n}\n\nexport default isKey","import { isFunction } from \"../checkTypes\";\n\n/**\n * Creates a function that memoizes the result of `func`. If `resolver` is\n * provided, it determines the cache key for storing the result based on the\n * arguments provided to the memoized function. By default, the first argument\n * provided to the memoized function is used as the map cache key. The `func`\n * is invoked with the `this` binding of the memoized function.\n *\n * **Note:** The cache is exposed as the `cache` property on the memoized\n * function. Its creation may be customized by replacing the `memoize.Cache`\n * constructor with one whose instances implement the\n * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n * method interface of `clear`, `delete`, `get`, `has`, and `set`.\n *\n*/\nexport type TKey =  [key?: TKey, ...rest: any[]]\nexport type TFunction = (...args:  TKey) => string[]\nexport type MemFunction = TFunction & {\n    cache? :Map<any,any>\n};\n\nconst memoize = (func:TFunction, resolver :TFunction) => {\n    if (!isFunction(func) || !isFunction(resolver)) {\n        throw new TypeError('Expected a function');\n    }\n    const memoized = (...args: TKey) => {\n        const key = resolver ? resolver.apply(null, args) : args[0];\n        const cache = memoized.cache as Map<any,any>;\n\n        if (cache.has(key)) {\n            return cache.get(key);\n        }\n        const result = func.apply(null, args);\n        memoized.cache = cache.set(key, result) || cache;\n        return result;\n    };\n    memoized.cache = new (memoize.Cache || Map)();\n    return memoized;\n}\n\nmemoize.Cache = Map;\n\nexport default memoize;","import memoize, {MemFunction, TFunction, TKey} from \"./memoize\";\n\n/** Used as the maximum memoize cache size. */\nconst MAX_MEMOIZE_SIZE = 500\n\n/**\n * A specialized version of `memoize` which clears the memoized function's\n * cache when it exceeds `MAX_MEMOIZE_SIZE`.\n */\nconst memoizeCapped = <T extends MemFunction>(func: TFunction) : T => {\n    const result = memoize(func, (...key : TKey) : string[] => {\n        const { cache } = result\n        if (cache?.size === MAX_MEMOIZE_SIZE) {\n            cache?.clear()\n        }\n        return key\n    }) as T\n\n    return result\n}\n\nexport default memoizeCapped","import memoizeCapped from './memoizeCapped'\nimport { isString } from \"../checkTypes\";\n\nconst charCodeOfDot = '.'.charCodeAt(0)\nconst reEscapeChar = /\\\\(\\\\)?/g\nconst rePropName = RegExp(\n    // Match anything that isn't a dot or bracket.\n    '[^.[\\\\]]+' + '|' +\n    // Or match property names within brackets.\n    '\\\\[(?:' +\n    // Match a non-string expression.\n    '([^\"\\'][^[]*)' + '|' +\n    // Or match strings (supports escaping characters).\n    '([\"\\'])((?:(?!\\\\2)[^\\\\\\\\]|\\\\\\\\.)*?)\\\\2' +\n    ')\\\\]'+ '|' +\n    // Or match \"\" as the space between consecutive dots or empty brackets.\n    '(?=(?:\\\\.|\\\\[\\\\])(?:\\\\.|\\\\[\\\\]|$))'\n    , 'g')\n\nconst stringToPath = memoizeCapped((str?: string | string[]) : string[]  => {\n    const result : string[] = []\n    if(!isString(str)) return result\n    if ((str as string)?.charCodeAt(0) === charCodeOfDot) {\n        result.push('')\n    }\n    (str as string)?.replace(rePropName, (match: string, expression?: string, quote?: string, subString?: string) : any   => {\n        let key = match\n        if (quote) {\n            key = subString?.replace(reEscapeChar, '$1') ?? ''\n        }\n        else if (expression) {\n            key = expression.trim()\n        }\n        result.push(key)\n    })\n    return result\n})\n\nexport default stringToPath"],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACEO,IAAM,YAAY,CAAI,UACzB,OAAO,UAAU,SAAS,KAAK,KAAK,EAAE,MAAM,GAAG,EAAE;AAK9C,IAAM,aAAa,CAAI,UAAa,UAAU,KAAK;AAEnD,IAAM,WAAW,CAAI,UAAa,UAAU,KAAK;;;ACNxD,IAAM,eAAe;AACrB,IAAM,gBAAgB;AAMtB,IAAM,QAAQ,CAAmB,OAAU,WAA6B;AACpE,MAAI,MAAM,QAAQ,KAAK,GAAG;AACtB,WAAO;AAAA,EACX;AAEA,MAAG,yFAA+D,EAAE,SAAS,UAAU,KAAK,CAAC,GAAG;AAC5F,WAAO;AAAA,EACX;AACA,SAAO,cAAc,KAAK,KAAK,KAAK,CAAC,aAAa,KAAK,KAAK,KACvD,UAAU,QAAQ,SAAS,OAAO,MAAM;AACjD;AAEA,IAAO,gBAAQ;;;ACDf,IAAM,UAAU,CAAC,MAAgB,aAAwB;AACrD,MAAI,CAAC,WAAW,IAAI,KAAK,CAAC,WAAW,QAAQ,GAAG;AAC5C,UAAM,IAAI,UAAU,qBAAqB;AAAA,EAC7C;AACA,QAAM,WAAW,IAAI,SAAe;AAChC,UAAM,MAAM,WAAW,SAAS,MAAM,MAAM,IAAI,IAAI,KAAK,CAAC;AAC1D,UAAM,QAAQ,SAAS;AAEvB,QAAI,MAAM,IAAI,GAAG,GAAG;AAChB,aAAO,MAAM,IAAI,GAAG;AAAA,IACxB;AACA,UAAM,SAAS,KAAK,MAAM,MAAM,IAAI;AACpC,aAAS,QAAQ,MAAM,IAAI,KAAK,MAAM,KAAK;AAC3C,WAAO;AAAA,EACX;AACA,WAAS,QAAQ,KAAK,QAAQ,SAAS,KAAK;AAC5C,SAAO;AACX;AAEA,QAAQ,QAAQ;AAEhB,IAAO,kBAAQ;;;ACxCf,IAAM,mBAAmB;AAMzB,IAAM,gBAAgB,CAAwB,SAAwB;AAClE,QAAM,SAAS,gBAAQ,MAAM,IAAI,QAA0B;AACvD,UAAM,EAAE,MAAM,IAAI;AAClB,SAAI,+BAAO,UAAS,kBAAkB;AAClC,qCAAO;AAAA,IACX;AACA,WAAO;AAAA,EACX,CAAC;AAED,SAAO;AACX;AAEA,IAAO,wBAAQ;;;AClBf,IAAM,gBAAgB,IAAI,WAAW,CAAC;AACtC,IAAM,eAAe;AACrB,IAAM,aAAa;AAAA;AAAA,EAEf;AAAA,EAUE;AAAG;AAET,IAAM,eAAe,sBAAc,CAAC,QAAwC;AACxE,QAAM,SAAoB,CAAC;AAC3B,MAAG,CAAC,SAAS,GAAG,EAAG,QAAO;AAC1B,OAAK,2BAAgB,WAAW,QAAO,eAAe;AAClD,WAAO,KAAK,EAAE;AAAA,EAClB;AACA,EAAC,2BAAgB,QAAQ,YAAY,CAAC,OAAe,YAAqB,OAAgB,cAA+B;AAzB7H;AA0BQ,QAAI,MAAM;AACV,QAAI,OAAO;AACP,aAAM,4CAAW,QAAQ,cAAc,UAAjC,YAA0C;AAAA,IACpD,WACS,YAAY;AACjB,YAAM,WAAW,KAAK;AAAA,IAC1B;AACA,WAAO,KAAK,GAAG;AAAA,EACnB;AACA,SAAO;AACX,CAAC;AAED,IAAO,uBAAQ;;;ALjCf,SAAS,SAAyB,OAAU,QAA2B;AACnE,MAAI,MAAM,QAAQ,KAAK,GAAG;AACtB,WAAO;AAAA,EACX;AACA,SAAO,cAAM,OAAO,MAAM,IAAI,CAAC,KAAK,IAAI,qBAAa,KAAK;AAC9D;AAEA,IAAO,mBAAQ;","names":[]}